// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'texture.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SurfaceTexture _$SurfaceTextureFromJson(Map<String, dynamic> json) {
  return PatternTexture.fromJson(json);
}

/// @nodoc
mixin _$SurfaceTexture {
  double get boxWidth => throw _privateConstructorUsedError;
  double get boxHeight => throw _privateConstructorUsedError;
  int get boxXCount => throw _privateConstructorUsedError;
  int get boxYCount => throw _privateConstructorUsedError;
  double get boxXSpace => throw _privateConstructorUsedError;
  double get boxYSpace => throw _privateConstructorUsedError;
  int get boxXColor => throw _privateConstructorUsedError;
  int get boxYColor => throw _privateConstructorUsedError;
  int get boxColor => throw _privateConstructorUsedError;
  double get boxXStroke => throw _privateConstructorUsedError;
  double get boxYStroke => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)
        pattern,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)?
        pattern,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)?
        pattern,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PatternTexture value) pattern,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PatternTexture value)? pattern,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PatternTexture value)? pattern,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SurfaceTextureCopyWith<SurfaceTexture> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SurfaceTextureCopyWith<$Res> {
  factory $SurfaceTextureCopyWith(
          SurfaceTexture value, $Res Function(SurfaceTexture) then) =
      _$SurfaceTextureCopyWithImpl<$Res, SurfaceTexture>;
  @useResult
  $Res call(
      {double boxWidth,
      double boxHeight,
      int boxXCount,
      int boxYCount,
      double boxXSpace,
      double boxYSpace,
      int boxXColor,
      int boxYColor,
      int boxColor,
      double boxXStroke,
      double boxYStroke});
}

/// @nodoc
class _$SurfaceTextureCopyWithImpl<$Res, $Val extends SurfaceTexture>
    implements $SurfaceTextureCopyWith<$Res> {
  _$SurfaceTextureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? boxXCount = null,
    Object? boxYCount = null,
    Object? boxXSpace = null,
    Object? boxYSpace = null,
    Object? boxXColor = null,
    Object? boxYColor = null,
    Object? boxColor = null,
    Object? boxXStroke = null,
    Object? boxYStroke = null,
  }) {
    return _then(_value.copyWith(
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      boxXCount: null == boxXCount
          ? _value.boxXCount
          : boxXCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxYCount: null == boxYCount
          ? _value.boxYCount
          : boxYCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxXSpace: null == boxXSpace
          ? _value.boxXSpace
          : boxXSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxYSpace: null == boxYSpace
          ? _value.boxYSpace
          : boxYSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxXColor: null == boxXColor
          ? _value.boxXColor
          : boxXColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxYColor: null == boxYColor
          ? _value.boxYColor
          : boxYColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxColor: null == boxColor
          ? _value.boxColor
          : boxColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxXStroke: null == boxXStroke
          ? _value.boxXStroke
          : boxXStroke // ignore: cast_nullable_to_non_nullable
              as double,
      boxYStroke: null == boxYStroke
          ? _value.boxYStroke
          : boxYStroke // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PatternTextureImplCopyWith<$Res>
    implements $SurfaceTextureCopyWith<$Res> {
  factory _$$PatternTextureImplCopyWith(_$PatternTextureImpl value,
          $Res Function(_$PatternTextureImpl) then) =
      __$$PatternTextureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double boxWidth,
      double boxHeight,
      int boxXCount,
      int boxYCount,
      double boxXSpace,
      double boxYSpace,
      int boxXColor,
      int boxYColor,
      int boxColor,
      double boxXStroke,
      double boxYStroke});
}

/// @nodoc
class __$$PatternTextureImplCopyWithImpl<$Res>
    extends _$SurfaceTextureCopyWithImpl<$Res, _$PatternTextureImpl>
    implements _$$PatternTextureImplCopyWith<$Res> {
  __$$PatternTextureImplCopyWithImpl(
      _$PatternTextureImpl _value, $Res Function(_$PatternTextureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? boxXCount = null,
    Object? boxYCount = null,
    Object? boxXSpace = null,
    Object? boxYSpace = null,
    Object? boxXColor = null,
    Object? boxYColor = null,
    Object? boxColor = null,
    Object? boxXStroke = null,
    Object? boxYStroke = null,
  }) {
    return _then(_$PatternTextureImpl(
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      boxXCount: null == boxXCount
          ? _value.boxXCount
          : boxXCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxYCount: null == boxYCount
          ? _value.boxYCount
          : boxYCount // ignore: cast_nullable_to_non_nullable
              as int,
      boxXSpace: null == boxXSpace
          ? _value.boxXSpace
          : boxXSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxYSpace: null == boxYSpace
          ? _value.boxYSpace
          : boxYSpace // ignore: cast_nullable_to_non_nullable
              as double,
      boxXColor: null == boxXColor
          ? _value.boxXColor
          : boxXColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxYColor: null == boxYColor
          ? _value.boxYColor
          : boxYColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxColor: null == boxColor
          ? _value.boxColor
          : boxColor // ignore: cast_nullable_to_non_nullable
              as int,
      boxXStroke: null == boxXStroke
          ? _value.boxXStroke
          : boxXStroke // ignore: cast_nullable_to_non_nullable
              as double,
      boxYStroke: null == boxYStroke
          ? _value.boxYStroke
          : boxYStroke // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PatternTextureImpl implements PatternTexture {
  const _$PatternTextureImpl(
      {this.boxWidth = 0,
      this.boxHeight = 0,
      this.boxXCount = 1,
      this.boxYCount = 1,
      this.boxXSpace = 0,
      this.boxYSpace = 0,
      this.boxXColor = BasicColors.blue,
      this.boxYColor = BasicColors.red,
      this.boxColor = BasicColors.white,
      this.boxXStroke = 0.5,
      this.boxYStroke = 0.5});

  factory _$PatternTextureImpl.fromJson(Map<String, dynamic> json) =>
      _$$PatternTextureImplFromJson(json);

  @override
  @JsonKey()
  final double boxWidth;
  @override
  @JsonKey()
  final double boxHeight;
  @override
  @JsonKey()
  final int boxXCount;
  @override
  @JsonKey()
  final int boxYCount;
  @override
  @JsonKey()
  final double boxXSpace;
  @override
  @JsonKey()
  final double boxYSpace;
  @override
  @JsonKey()
  final int boxXColor;
  @override
  @JsonKey()
  final int boxYColor;
  @override
  @JsonKey()
  final int boxColor;
  @override
  @JsonKey()
  final double boxXStroke;
  @override
  @JsonKey()
  final double boxYStroke;

  @override
  String toString() {
    return 'SurfaceTexture.pattern(boxWidth: $boxWidth, boxHeight: $boxHeight, boxXCount: $boxXCount, boxYCount: $boxYCount, boxXSpace: $boxXSpace, boxYSpace: $boxYSpace, boxXColor: $boxXColor, boxYColor: $boxYColor, boxColor: $boxColor, boxXStroke: $boxXStroke, boxYStroke: $boxYStroke)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PatternTextureImpl &&
            (identical(other.boxWidth, boxWidth) ||
                other.boxWidth == boxWidth) &&
            (identical(other.boxHeight, boxHeight) ||
                other.boxHeight == boxHeight) &&
            (identical(other.boxXCount, boxXCount) ||
                other.boxXCount == boxXCount) &&
            (identical(other.boxYCount, boxYCount) ||
                other.boxYCount == boxYCount) &&
            (identical(other.boxXSpace, boxXSpace) ||
                other.boxXSpace == boxXSpace) &&
            (identical(other.boxYSpace, boxYSpace) ||
                other.boxYSpace == boxYSpace) &&
            (identical(other.boxXColor, boxXColor) ||
                other.boxXColor == boxXColor) &&
            (identical(other.boxYColor, boxYColor) ||
                other.boxYColor == boxYColor) &&
            (identical(other.boxColor, boxColor) ||
                other.boxColor == boxColor) &&
            (identical(other.boxXStroke, boxXStroke) ||
                other.boxXStroke == boxXStroke) &&
            (identical(other.boxYStroke, boxYStroke) ||
                other.boxYStroke == boxYStroke));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      boxWidth,
      boxHeight,
      boxXCount,
      boxYCount,
      boxXSpace,
      boxYSpace,
      boxXColor,
      boxYColor,
      boxColor,
      boxXStroke,
      boxYStroke);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PatternTextureImplCopyWith<_$PatternTextureImpl> get copyWith =>
      __$$PatternTextureImplCopyWithImpl<_$PatternTextureImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)
        pattern,
  }) {
    return pattern(boxWidth, boxHeight, boxXCount, boxYCount, boxXSpace,
        boxYSpace, boxXColor, boxYColor, boxColor, boxXStroke, boxYStroke);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)?
        pattern,
  }) {
    return pattern?.call(boxWidth, boxHeight, boxXCount, boxYCount, boxXSpace,
        boxYSpace, boxXColor, boxYColor, boxColor, boxXStroke, boxYStroke);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            double boxWidth,
            double boxHeight,
            int boxXCount,
            int boxYCount,
            double boxXSpace,
            double boxYSpace,
            int boxXColor,
            int boxYColor,
            int boxColor,
            double boxXStroke,
            double boxYStroke)?
        pattern,
    required TResult orElse(),
  }) {
    if (pattern != null) {
      return pattern(boxWidth, boxHeight, boxXCount, boxYCount, boxXSpace,
          boxYSpace, boxXColor, boxYColor, boxColor, boxXStroke, boxYStroke);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PatternTexture value) pattern,
  }) {
    return pattern(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PatternTexture value)? pattern,
  }) {
    return pattern?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PatternTexture value)? pattern,
    required TResult orElse(),
  }) {
    if (pattern != null) {
      return pattern(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PatternTextureImplToJson(
      this,
    );
  }
}

abstract class PatternTexture implements SurfaceTexture {
  const factory PatternTexture(
      {final double boxWidth,
      final double boxHeight,
      final int boxXCount,
      final int boxYCount,
      final double boxXSpace,
      final double boxYSpace,
      final int boxXColor,
      final int boxYColor,
      final int boxColor,
      final double boxXStroke,
      final double boxYStroke}) = _$PatternTextureImpl;

  factory PatternTexture.fromJson(Map<String, dynamic> json) =
      _$PatternTextureImpl.fromJson;

  @override
  double get boxWidth;
  @override
  double get boxHeight;
  @override
  int get boxXCount;
  @override
  int get boxYCount;
  @override
  double get boxXSpace;
  @override
  double get boxYSpace;
  @override
  int get boxXColor;
  @override
  int get boxYColor;
  @override
  int get boxColor;
  @override
  double get boxXStroke;
  @override
  double get boxYStroke;
  @override
  @JsonKey(ignore: true)
  _$$PatternTextureImplCopyWith<_$PatternTextureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
